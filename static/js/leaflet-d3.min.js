/*! @asymmetrik/leaflet-d3 - 3.1.1 - Copyright (c) 2007-2017 Asymmetrik Ltd, a Maryland Corporation */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("d3"),require("d3-hexbin"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","d3","d3-hexbin","leaflet"],n):n(t.leafletD3={},t.d3,t.d3.hexbin)}(this,function(t,n,i){"use strict";/**
 * This is a convoluted way of getting ahold of the hexbin function.
 * - When imported globally, d3 is exposed in the global namespace as 'd3'
 * - When imported using a module system, it's a named import (and can't collide with d3)
 * - When someone isn't importing d3-hexbin, the named import will be undefined
 *
 * As a result, we have to figure out how it's being imported and get the function reference
 * (which is why we have this convoluted nested ternary statement
 */
var e=null!=n.hexbin?n.hexbin:null!=i?i.hexbin:null;/**
 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
 * We extend L.SVG to take advantage of built-in zoom animations.
 */
L.HexbinLayer=L.SVG.extend({includes:[L.Mixin.Events],/**
	 * Default options
	 */
options:{radius:12,opacity:.6,duration:200,colorScaleExtent:[1,void 0],radiusScaleExtent:[1,void 0],colorRange:["#f7fbff","#08306b"],radiusRange:[4,12],pointerEvents:"all"},/**
	 * Standard Leaflet initialize function, accepting an options argument provided by the
	 * user when they create the layer
	 * @param options Options object where the options override the defaults
	 */
initialize:function(t){L.setOptions(this,t),
// Set up the various overrideable functions
this._fn={lng:function(t){return t[0]},lat:function(t){return t[1]},colorValue:function(t){return t.length},radiusValue:function(t){return Number.MAX_VALUE},fill:function(t){var n=this._fn.colorValue(t);return null!=n?this._scale.color(n):"none"}},
// Set up the customizable scale
this._scale={color:n.scaleLinear(),radius:n.scaleLinear()},
// Set up the Dispatcher for managing events and callbacks
this._dispatch=n.dispatch("mouseover","mouseout","click"),
// Set up the default hover handler
this._hoverHandler=L.HexbinHoverHandler.none(),
// Create the hex layout
this._hexLayout=e().radius(this.options.radius).x(function(t){return t.point[0]}).y(function(t){return t.point[1]}),
// Initialize the data array to be empty
this._data=[],this._scale.color.range(this.options.colorRange).clamp(!0),this._scale.radius.range(this.options.radiusRange).clamp(!0)},/**
	 * Callback made by Leaflet when the layer is added to the map
	 * @param map Reference to the map to which this layer has been added
	 */
onAdd:function(t){L.SVG.prototype.onAdd.call(this),
// Store a reference to the map for later use
this._map=t,
// Redraw on moveend
t.on({moveend:this.redraw},this),
// Initial draw
this.redraw()},/**
	 * Callback made by Leaflet when the layer is removed from the map
	 * @param map Reference to the map from which this layer is being removed
	 */
onRemove:function(t){L.SVG.prototype.onRemove.call(this),
// Destroy the svg container
this._destroyContainer(),
// Remove events
t.off({moveend:this.redraw},this),this._map=null},/**
	 * Create the SVG container for the hexbins
	 * @private
	 */
_initContainer:function(){L.SVG.prototype._initContainer.call(this),this._d3Container=n.select(this._container).select("g")},/**
	 * Clean up the svg container
	 * @private
	 */
_destroyContainer:function(){},/**
	 * (Re)draws the hexbins data on the container
	 * @private
	 */
redraw:function(){var t=this;if(t._map){
// Generate the mapped version of the data
var n=t._data.map(function(n){var i=t._fn.lng(n),e=t._fn.lat(n);return{o:n,point:t._project([i,e])}}),i=this._d3Container.selectAll("g.hexbin").data([this._map.getZoom()],function(t){return t}),e=i.enter().append("g").attr("class",function(t){return"hexbin zoom-"+t}).merge(i);
// exit
i.exit().remove(),
// add the hexagons to the select
this._createHexagons(e,n)}},_createHexagons:function(t,n){var i=this,e=i._map.getBounds(),a=i._hexLayout(n),o=i._getExtent(a,i._fn.colorValue,i.options.colorScaleExtent),r=i._getExtent(a,i._fn.radiusValue,i.options.radiusScaleExtent),s=i._linearlySpace(o[0],o[1],i._scale.color.range().length);
// Set the scale domains
i._scale.color.domain(s),i._scale.radius.domain(r),/*
		 * Join
		 *    Join the Hexagons to the data
		 *    Use a deterministic id for tracking bins based on position
		 */
a=a.filter(function(t){return e.contains(i._map.layerPointToLatLng(L.point(t.x,t.y)))});var l=t.selectAll("g.hexbin-container").data(a,function(t){return t.x+":"+t.y});/*
		 * Update
		 *    Set the fill and opacity on a transition
		 *    opacity is re-applied in case the enter transition was cancelled
		 *    the path is applied as well to resize the bins
		 */
l.select("path.hexbin-hexagon").transition().duration(i.options.duration).attr("fill",i._fn.fill.bind(i)).attr("fill-opacity",i.options.opacity).attr("stroke-opacity",i.options.opacity).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius(i._fn.radiusValue.call(i,t)))});/*
		 * Enter
		 *    Establish the path, size, fill, and the initial opacity
		 *    Transition to the final opacity and size
		 */
var u=l.enter().append("g").attr("class","hexbin-container");u.append("path").attr("class","hexbin-hexagon").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius.range()[0])}).attr("fill",i._fn.fill.bind(i)).attr("fill-opacity",.01).attr("stroke-opacity",.01).transition().duration(i.options.duration).attr("fill-opacity",i.options.opacity).attr("stroke-opacity",i.options.opacity).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius(i._fn.radiusValue.call(i,t)))}),
// Grid
u.append("path").attr("class","hexbin-grid").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return i._hexLayout.hexagon(i.options.radius)}).attr("fill","none").attr("stroke","none").style("pointer-events",i.options.pointerEvents).on("mouseover",function(t,n){i._hoverHandler.mouseover.call(this,i,t,n),i._dispatch.call("mouseover",this,t,n)}).on("mouseout",function(t,n){i._dispatch.call("mouseout",this,t,n),i._hoverHandler.mouseout.call(this,i,t,n)}).on("click",function(t,n){i._dispatch.call("click",this,t,n)});
// Exit
var c=l.exit();c.select("path.hexbin-hexagon").transition().duration(i.options.duration).attr("fill-opacity",0).attr("stroke-opacity",0).attr("d",function(t){return i._hexLayout.hexagon(0)}),c.transition().duration(i.options.duration).remove()},_getExtent:function(t,i,e){
// Determine the extent of the values
var a=n.extent(t,i.bind(this));
// If either's null, initialize them to 0
// Now apply the optional clipping of the extent
return null==a[0]&&(a[0]=0),null==a[1]&&(a[1]=0),null!=e[0]&&(a[0]=e[0]),null!=e[1]&&(a[1]=e[1]),a},_project:function(t){var n=this._map.latLngToLayerPoint([t[1],t[0]]);return[n.x,n.y]},_getBounds:function(t){if(null==t||t.length<1)return{min:[0,0],max:[0,0]};
// bounds is [[min long, min lat], [max long, max lat]]
var n=[[999,999],[-999,-999]];return t.forEach(function(t){var i=t.point[0],e=t.point[1];n[0][0]=Math.min(n[0][0],i),n[0][1]=Math.min(n[0][1],e),n[1][0]=Math.max(n[1][0],i),n[1][1]=Math.max(n[1][1],e)}),{min:n[0],max:n[1]}},_linearlySpace:function(t,n,i){for(var e=new Array(i),a=(n-t)/Math.max(i-1,1),o=0;o<i;++o)e[o]=t+o*a;return e},
// ------------------------------------
// Public API
// ------------------------------------
radius:function(t){return arguments.length?(this.options.radius=t,this._hexLayout.radius(t),this):this.options.radius},opacity:function(t){return arguments.length?(this.options.opacity=t,this):this.options.opacity},duration:function(t){return arguments.length?(this.options.duration=t,this):this.options.duration},colorScaleExtent:function(t){return arguments.length?(this.options.colorScaleExtent=t,this):this.options.colorScaleExtent},radiusScaleExtent:function(t){return arguments.length?(this.options.radiusScaleExtent=t,this):this.options.radiusScaleExtent},colorRange:function(t){return arguments.length?(this.options.colorRange=t,this._scale.color.range(t),this):this.options.colorRange},radiusRange:function(t){return arguments.length?(this.options.radiusRange=t,this._scale.radius.range(t),this):this.options.radiusRange},colorScale:function(t){return arguments.length?(this._scale.color=t,this):this._scale.color},radiusScale:function(t){return arguments.length?(this._scale.radius=t,this):this._scale.radius},lng:function(t){return arguments.length?(this._fn.lng=t,this):this._fn.lng},lat:function(t){return arguments.length?(this._fn.lat=t,this):this._fn.lat},colorValue:function(t){return arguments.length?(this._fn.colorValue=t,this):this._fn.colorValue},radiusValue:function(t){return arguments.length?(this._fn.radiusValue=t,this):this._fn.radiusValue},fill:function(t){return arguments.length?(this._fn.fill=t,this):this._fn.fill},data:function(t){return arguments.length?(this._data=null!=t?t:[],this.redraw(),this):this._data},/*
	 * Getter for the event dispatcher
	 */
dispatch:function(){return this._dispatch},hoverHandler:function(t){return arguments.length?(this._hoverHandler=null!=t?t:L.HexbinHoverHandler.none(),this.redraw(),this):this._hoverHandler},/*
	 * Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	 */
getLatLngs:function(){var t=this;
// Map the data into an array of latLngs using the configured lat/lng accessors
return this._data.map(function(n){return L.latLng(t.options.lat(n),t.options.lng(n))})},/*
	 * Get path geometry as GeoJSON
	 */
toGeoJSON:function(){return L.GeoJSON.getFeature(this,{type:"LineString",coordinates:L.GeoJSON.latLngsToCoords(this.getLatLngs(),0)})}}),
// Hover Handlers modify the hexagon and can be combined
L.HexbinHoverHandler={tooltip:function(t){null==(
// merge options with defaults
t=t||{}).tooltipContent&&(t.tooltipContent=function(t){return"Count: "+t.length});
// Generate the tooltip
var i=n.select("body").append("div").attr("class","hexbin-tooltip").style("z-index",9999).style("pointer-events","none").style("visibility","hidden").style("position","absolute");
// return the handler instance
return i.append("div").attr("class","tooltip-content"),{mouseover:function(e,a){var o=n.event,r=n.mouse(this);i.style("visibility","visible").html(t.tooltipContent(a,e));var s=null;null!=i._groups&&i._groups.length>0&&i._groups[0].length>0&&(s=i._groups[0][0]);var l=s.clientHeight,u=s.clientWidth;i.style("top",""+o.clientY-r[1]-l-16+"px").style("left",""+o.clientX-r[0]-u/2+"px")},mouseout:function(t,n){i.style("visibility","hidden").html()}}},resizeFill:function(){
// return the handler instance
return{mouseover:function(t,i){n.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(n){return t._hexLayout.hexagon(t.options.radius)})},mouseout:function(t,i){n.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(n){return t._hexLayout.hexagon(t._scale.radius(t._fn.radiusValue.call(t,n)))})}}},resizeScale:function(t){
// return the handler instance
// merge options with defaults
return null==(t=t||{}).radiusScale&&(t.radiusScale=.5),{mouseover:function(i,e){n.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(n){return i._hexLayout.hexagon(i._scale.radius.range()[1]*(1+t.radiusScale))})},mouseout:function(t,i){n.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(n){return t._hexLayout.hexagon(t._scale.radius(t._fn.radiusValue.call(t,n)))})}}},compound:function(t){return null==(t=t||{}).handlers&&(t.handlers=[L.HexbinHoverHandler.none()]),{mouseover:function(n,i){var e=this;t.handlers.forEach(function(t){t.mouseover.call(e,n,i)})},mouseout:function(n,i){var e=this;t.handlers.forEach(function(t){t.mouseout.call(e,n,i)})}}},none:function(){return{mouseover:function(){},mouseout:function(){}}}},L.hexbinLayer=function(t){return new L.HexbinLayer(t)},/**
 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
 * We extend L.SVG to take advantage of built-in zoom animations.
 */
L.PingLayer=L.SVG.extend({includes:[L.Mixin.Events],/*
	 * Default options
	 */
options:{duration:800,fps:32,opacityRange:[1,0],radiusRange:[3,15]},
// Initialization of the plugin
initialize:function(t){L.setOptions(this,t),this._fn={lng:function(t){return t[0]},lat:function(t){return t[1]},radiusScaleFactor:function(t){return 1}},this._scale={radius:n.scalePow().exponent(.35),opacity:n.scaleLinear()},this._lastUpdate=Date.now(),this._fps=0,this._scale.radius.domain([0,this.options.duration]).range(this.options.radiusRange).clamp(!0),this._scale.opacity.domain([0,this.options.duration]).range(this.options.opacityRange).clamp(!0)},
// Called when the plugin layer is added to the map
onAdd:function(t){L.SVG.prototype.onAdd.call(this),
// Store a reference to the map for later use
this._map=t,
// Init the state of the simulation
this._running=!1,
// Set up events
t.on({move:this._updateContainer},this)},
// Called when the plugin layer is removed from the map
onRemove:function(t){L.SVG.prototype.onRemove.call(this),
// Destroy the svg container
this._destroyContainer(),
// Remove events
t.off({move:this._updateContainer},this),this._map=null,this._data=null},/*
	 * Private Methods
	 */
// Initialize the Container - creates the svg pane
_initContainer:function(){L.SVG.prototype._initContainer.call(this),this._d3Container=n.select(this._container).select("g")},
// Update the container - Updates the dimensions of the svg pane
_updateContainer:function(){this._updatePings(!0)},
// Cleanup the svg pane
_destroyContainer:function(){},
// Calculate the circle coordinates for the provided data
_getCircleCoords:function(t){var n=this._map.latLngToLayerPoint(t);return{x:n.x,y:n.y}},
// Add a ping to the map
_addPing:function(t,n){
// Lazy init the data array
null==this._data&&(this._data=[]);
// Derive the spatial data
var i=[this._fn.lat(t),this._fn.lng(t)],e=this._getCircleCoords(i),a={data:t,geo:i,ts:Date.now(),nts:0};a.c=this._d3Container.append("circle").attr("class",null!=n?"ping "+n:"ping").attr("cx",e.x).attr("cy",e.y).attr("r",this._fn.radiusScaleFactor.call(this,t)*this._scale.radius.range()[0]),
// Push new circles
this._data.push(a)},
// Main update loop
_updatePings:function(t){var n=Date.now();null==this._data&&(this._data=[]);
// Update everything
for(var i=-1,e=0;e<this._data.length;e++){var a=this._data[e],o=n-a.ts;if(this.options.duration<o)
// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
a.c.remove(),i=e;else
// If the blip is still alive, process it
if(t||a.nts<n){var r=this._getCircleCoords(a.geo);a.c.attr("cx",r.x).attr("cy",r.y).attr("r",this._fn.radiusScaleFactor.call(this,a.data)*this._scale.radius(o)).attr("fill-opacity",this._scale.opacity(o)).attr("stroke-opacity",this._scale.opacity(o)),a.nts=Math.round(n+1e3/this.options.fps)}}
// Delete all the aged off data at once
// The return function dictates whether the timer loop will continue
return i>-1&&this._data.splice(0,i+1),this._running=this._data.length>0,this._running&&(this._fps=1e3/(n-this._lastUpdate),this._lastUpdate=n),!this._running},
// Expire old pings
_expirePings:function(){
// Search from the front of the array
for(var t=-1,n=Date.now(),i=0;i<this._data.length;i++){var e=this._data[i],a=n-e.ts;if(!(this.options.duration<a))break;
// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
e.c.remove(),t=i}
// Delete all the aged off data at once
t>-1&&this._data.splice(0,t+1)},/*
	 * Public Methods
	 */
duration:function(t){return arguments.length?(this.options.duration=t,this):this.options.duration},fps:function(t){return arguments.length?(this.options.fps=t,this):this.options.fps},lng:function(t){return arguments.length?(this._fn.lng=t,this):this._fn.lng},lat:function(t){return arguments.length?(this._fn.lat=t,this):this._fn.lat},radiusRange:function(t){return arguments.length?(this.options.radiusRange=t,this._scale.radius().range(t),this):this.options.radiusRange},opacityRange:function(t){return arguments.length?(this.options.opacityRange=t,this._scale.opacity().range(t),this):this.options.opacityRange},radiusScale:function(t){return arguments.length?(this._scale.radius=t,this):this._scale.radius},opacityScale:function(t){return arguments.length?(this._scale.opacity=t,this):this._scale.opacity},radiusScaleFactor:function(t){return arguments.length?(this._fn.radiusScaleFactor=t,this):this._fn.radiusScaleFactor},/*
	 * Method by which to "add" pings
	 */
ping:function(t,i){
// Start timer if not active
if(this._addPing(t,i),this._expirePings(),!this._running&&this._data.length>0){this._running=!0,this._lastUpdate=Date.now();var e=this;n.timer(function(){e._updatePings.call(e,!1)})}return this},getActualFps:function(){return this._fps},data:function(){return this._data}}),L.pingLayer=function(t){return new L.PingLayer(t)},Object.defineProperty(t,"__esModule",{value:!0})});